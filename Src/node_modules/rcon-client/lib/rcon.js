"use strict";
const net_1 = require("net");
const event_kit_1 = require("event-kit");
const packet_1 = require("./packet");
const splitter_1 = require("./splitter");
const queue_1 = require("./utils/queue");
class Rcon {
    constructor(options) {
        this.options = {
            packetResponseTimeout: 1000
        };
        this.emitter = new event_kit_1.Emitter();
        this.requestId = 0;
        if (options)
            this.options = Object.assign(this.options, options);
        this.sendPacketQueue = new queue_1.PromiseQueue({ maxConcurrent: 1 });
    }
    onDidConnect(callback) {
        return this.emitter.on("did-connect", callback);
    }
    onDidAuthenticate(callback) {
        return this.emitter.on("did-authenticate", callback);
    }
    onDidDisconnect(callback) {
        return this.emitter.on("did-disconnect", callback);
    }
    connect(options) {
        if (this.authenticated)
            return Promise.resolve();
        const { host, port, password } = options;
        const promise = new Promise((resolve, reject) => {
            const onConnected = () => {
                this.emitter.emit("did-connect", null);
                this.socket.removeListener("error", connectErrorHandler);
                this.subscribeToSocketEvents();
                this.connecting = false;
                this.sendPacketQueue.resume();
                const id = this.requestId;
                this.sendPacket(packet_1.PacketType.Auth, options.password, true)
                    .then((packet) => {
                    if (packet.id != id || packet.id == -1)
                        return reject(new Error("Authentication failed: wrong password"));
                    this.authenticated = true;
                    this.emitter.emit("did-authenticate", null);
                    resolve();
                });
            };
            this.socket = net_1.createConnection({ host, port }, onConnected);
            const connectErrorHandler = err => reject(err);
            this.socket.on("error", connectErrorHandler);
            this.connecting = true;
        });
        return promise;
    }
    disconnect() {
        this.socket.end();
        this.authenticated = false;
        this.sendPacketQueue.pause();
        return new Promise((resolve, reject) => {
            const listener = this.onDidDisconnect(() => {
                resolve();
                listener.dispose();
            });
        });
    }
    end() {
        return this.disconnect();
    }
    send(command) {
        return this.sendPacket(packet_1.PacketType.Command, command)
            .then(packet => packet.payload);
    }
    sendPacket(type, payload, isAuth = false) {
        const id = this.requestId++;
        const createPacketResponsePromise = () => new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                packetListener.dispose();
                reject(new Error(`Response timeout for packet id ${id}`));
            }, this.options.packetResponseTimeout);
            const packetListener = this.onPacket(packet => {
                if (!isAuth && packet.id == id || isAuth) {
                    clearTimeout(timeout);
                    packetListener.dispose();
                    resolve(packet);
                }
            });
        });
        const createQueuedPromise = () => this.sendPacketQueue.add(() => {
            this.socket.write(packet_1.encodePacket({ id, type, payload }));
            return createPacketResponsePromise();
        });
        if (isAuth || this.authenticated) {
            return createQueuedPromise();
        }
        else {
            return new Promise((resolve, reject) => {
                const listener = this.onDidAuthenticate(() => {
                    resolve();
                    listener.dispose();
                });
            })
                .then(createQueuedPromise);
        }
    }
    onPacket(callback) {
        return this.emitter.on("packet", (packet) => {
            callback(packet);
        });
    }
    subscribeToSocketEvents() {
        this.socket.on("close", () => {
            this.authenticated = false;
            this.sendPacketQueue.pause();
            this.socket = null;
            this.emitter.emit("did-disconnect", null);
        });
        this.socket.on("error", error => {
            throw error;
        });
        this.socket
            .pipe(splitter_1.createSplitter())
            .on("data", (data) => {
            this.emitter.emit("packet", packet_1.decodePacket(data));
        });
    }
}
exports.Rcon = Rcon;
