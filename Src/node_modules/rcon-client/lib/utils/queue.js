"use strict";
class PromiseQueue {
    constructor(options) {
        this.queue = [];
        this.pendingPromisesCount = 0;
        this.paused = false;
        if (!options)
            options = {};
        this.maxConcurrent = options.maxConcurrent || 1;
    }
    add(promiseGenerator) {
        return new Promise((resolve, reject) => {
            this.queue.push({ promiseGenerator, resolve, reject });
            if (!this.paused)
                this.dequeue();
        });
    }
    pause() {
        this.paused = true;
    }
    resume() {
        this.paused = false;
        this.dequeue();
    }
    dequeue() {
        if (this.pendingPromisesCount > this.maxConcurrent || this.paused)
            return;
        let item = this.queue.shift();
        if (!item)
            return;
        this.pendingPromisesCount++;
        let onPromiseResolvedOrRejected = () => {
            this.pendingPromisesCount--;
            this.dequeue();
        };
        item.promiseGenerator()
            .then(value => {
            item.resolve(value);
            onPromiseResolvedOrRejected();
        })
            .catch(e => {
            item.reject(e);
            onPromiseResolvedOrRejected();
        });
    }
}
exports.PromiseQueue = PromiseQueue;
